Package P4.P4;

Helpers
    digit = ['0' .. '9'];
    letter = ['a' .. 'z'] |['A' .. 'Z'];
    cr = 13;
    lf = 10;
    tab = 9;
    eol = cr lf | cr | lf;
    blank = (' ' | tab | eol)+;
    all = [0 .. 0xFFFF];
    not_cr_lf = [all - [cr + lf]];

Tokens
    blank = blank;
    id = letter (letter |digit)*;
    comment = '//' not_cr_lf* eol;
    bool_literal = 'true'|'false';
    add_op = '+' | '-';
    mult_op = '*' | '/' | '%';
    int_literal = digit*;
    float_literal = ['1' .. '9'] digit*'.'digit*;
    string = ''' [not_cr_lf - ''']* ''';
    bool_op = '||' | '&&';
    relation_op = '<' | '>' | '<=' | '>=';
    assign = '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=';
    equal_op = '==' | '!=';
    l_paren = '(';
    r_paren = ')';
    l_brack = '{';
    r_brack = '}';
    setup = 'Setup';
    players = 'Players';
    decks = 'Decks';
    public = 'Public';
    private = 'Private';
    new = 'new';
    separator = ',';
    dot = '.';
    moves = 'Moves';
    l_box = '[';
    r_box = ']';
    return = 'return';
    semi = ';';
    if = 'if';
    else = 'else';
    switch = 'switch';
    case = 'case';
    default = 'default';
    colon = ':';
    while = 'while';
    for = 'for';
    foreach = 'foreach';
    turn = 'Turn';
    end_con = 'EndCondition';
    in = 'in';
    type = 'int' | 'float' | 'string' | 'bool' | 'Card' | 'Player' | 'void';
    l_arr = '<';
    r_arr = '>';
    list = 'List';

Ignored Tokens
    blank,
    comment;

Productions
    prog = P.setup P.moves P.turn P.end_con;
    setup = T.setup l_brack P.players P.decks P.public P.private r_brack;
    players = T.players dcl_block;
    decks = T.decks dcl_block;
    public = T.public dcl_block;
    private = T.private dcl_block;
    moves = T.moves dcl_block;
    dcl_block = l_brack dcl_list r_brack;
    dcl_list = {list} dcl separator dcl_list | {empty} ;
    dcl = P.type id assign P.new expr semi;
    new = {new} T.new | {empty};
    expr = {expand} expr bool_op equality | {single} equality;
    equality = {expand} equality equal_op  relation  | {single} relation;
    relation = {expand} relation relation_op add_expr | {single} add_expr;
    add_expr = {expand} add_expr add_op term | {single} term;
    term = {expand} term mult_op factor | {factor} factor;
    factor = {expand} parens | {literal} literal | {var} var | {call} call;
    parens = l_paren expr r_paren;
    literal = {int} int_literal | {float} float_literal | {string} string | {bool} bool_literal;
    var = member_method_list id;
    member_method_list = {expand} member_method* dot | {empty};
    member_method = id method;
    method = {method} param_list |{empty};
    call = member_method_list param_list ;
    param_list = l_paren expr? param* r_paren;
    param = separator expr;
    move_dcl_list = method_dcl move_dcl_list;
    method_dcl = P.type id l_paren param_dcl_list r_paren l_brack stmt_list return_stmt r_brack;
    param_dcl_list = {expand} param_dcl separator param_dcl_list | {single} param_dcl;
    param_dcl = {single} P.type id | {empty};
    type = {type} T.type | {collection} collection;
    collection = {array} array | {list} P.list;
    array = T.type l_brack r_brack;
    list = T.list l_arr T.type r_arr;
    stmt_list = {expand} stmt stmt_list | {empty};
    return_stmt = {single} return expr | {empty};
    stmt = {select} select_stmt | {dcl} dcl | {loop} loop_stmt | {call} call semi;
    select_stmt = {if} if_stmt | {switch} switch_stmt;
    stmt_block = l_brack stmt_list r_brack;
    if_stmt = if l_paren expr r_paren stmt_block else_stmt;
    else_stmt = {elseif} else if_stmt | {else} else stmt_block |;
    switch_stmt = switch l_paren var l_brack case_list r_brack;
    case_list = {list} case_stmt case_list | {default} default_stmt |{empty};
    case_stmt = case colon stmt_block;
    default_stmt = default colon stmt_block;
    loop_stmt = {while} while_loop | {for} for_loop | {foreach} for_each_loop;
    while_loop = while l_paren expr r_paren stmt_block;
    for_loop = for l_paren [init]:expr [a]:semi [condition]:expr [b]:semi [count]:expr r_paren stmt_block;
    for_each_loop = foreach l_paren P.type [var]:id in [collection]:id r_paren stmt_block;
    turn = T.turn stmt_block;
    end_con = T.end_con stmt_block;

