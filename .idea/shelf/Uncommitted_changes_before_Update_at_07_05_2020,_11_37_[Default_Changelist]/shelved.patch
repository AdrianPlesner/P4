Index: src/P4/contextualAnalysis/TypeChecker.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package P4.contextualAnalysis;\n\nimport P4.Sable.analysis.DepthFirstAdapter;\nimport P4.Sable.node.*;\nimport P4.contextualAnalysis.SymbolTable;\n\nimport java.lang.reflect.Type;\nimport java.nio.MappedByteBuffer;\n\npublic class TypeChecker extends DepthFirstAdapter {\n\n    SymbolTable st;\n    private TokenFinder tf = new TokenFinder();\n\n    public TypeChecker(Start ast, SymbolTable _st) throws TypeException {\n        ast.apply(this);\n        st = _st;\n    }\n\n    @Override\n    public void caseStart(Start node) throws TypeException {\n        // Check everything. No need to change anything\n        super.caseStart(node);\n    }\n\n    @Override\n    public void caseAProg(AProg node) throws TypeException{\n        //Apply everything!\n        var setup = node.getSetup();\n        setup.apply(this);\n\n        for (PMethodDcl moves : node.getMoves()){\n            moves.apply(this);\n        }\n        for (PStmt turn : node.getTurn()){\n            turn.apply(this);\n        }\n        for (PStmt endCondition : node.getEndCondition()){\n            endCondition.apply(this);\n        }\n        for (PMethodDcl methods : node.getMethods()){\n            methods.apply(this);\n        }\n\n        //TODO: What to do with linked list of TId?\n    }\n\n    @Override\n    public void caseAClassBody(AClassBody node) throws TypeException{\n        // Apply everything\n        for (PStmt ps : node.getDcls()){\n            ps.apply(this);\n        }\n        for (PMethodDcl pMetDcl : node.getMethods()){\n            pMetDcl.apply(this);\n        }\n        for (PSubclass pSub : node.getSubclasses()){\n            pSub.apply(this);\n        }\n\n        var pConstruct = node.getConstruct();\n        pConstruct.apply(this);\n    }\n\n    @Override\n    public void caseAConstruct(AConstruct node) throws TypeException{\n        for (PStmt ps : node.getBody()){\n            ps.apply(this);\n        }\n\n        for (PParamDcl pParamDcl : node.getParams()){\n            pParamDcl.apply(this);\n        }\n\n        //TODO: Probably not done\n    }\n\n    @Override\n    public void caseALiteralExpr(ALiteralExpr node) throws TypeException {\n        // Set type of literal\n        node.getValue().apply(this);\n\n        // Set expr type to type of literal\n        node.type = node.getValue().type;\n\n    }\n\n    @Override\n    public void caseAIntLiteral(AIntLiteral node) {\n        // Set type of int literal\n        node.type = \"int\";\n    }\n\n    @Override\n    public void caseABoolLiteral(ABoolLiteral node) {\n        // Set type of boolean literal\n        node.type = \"bool\";\n    }\n\n    @Override\n    public void caseAFloatLiteral(AFloatLiteral node) {\n        // Set type of float literal\n        node.type = \"float\";\n    }\n\n    @Override\n    public void caseAStringLiteral(AStringLiteral node){\n        // Set type of string literal\n        node.type = \"string\";\n    }\n\n    @Override\n    public void caseAValueExpr(AValueExpr node) throws TypeException {\n        // visit children\n        node.getVal().apply(this);\n        // Set type to type of child\n        node.type = node.getVal().type;\n    }\n\n    @Override\n    public void caseAAddOpExpr(AAddOpExpr node) throws TypeException {\n        // check children\n        var L = node.getL();\n        L.apply(this);\n        var R = node.getR();\n        R.apply(this);\n\n        if(L.type.equals(R.type)){\n            // each operand is of the same time. check it is a type that can do the operation\n            switch(L.type){\n                case \"string\":{\n                    if(node.getOperator().getText().trim().equals(\"-\")){\n                        // cant substract strings\n                        throw new TypeException(node.getOperator(),\"Cannot substract strings\");\n                    }\n                }\n                case \"int\": case \"float\":{\n                    node.type = L.type;\n                    break;\n                }\n                default:{\n                    // incompatible types\n                    throw new TypeException(node.getOperator(),\"Operation cannot be done on operands of type \" + L.type);\n                }\n            }\n        }\n        else{\n            //Operands are of different types\n            if (L.type.equals(\"int\") && R.type.equals(\"float\") || L.type.equals(\"float\") && R.type.equals(\"int\")){\n                node.type = \"float\";\n            } else {\n                throw new TypeException(node.getOperator(), \"Operation cannot be done on operands of type \" + L.type + \" and \" + R.type);\n            }\n        }\n    }\n\n    @Override\n    public void caseAMultOpExpr(AMultOpExpr node) throws TypeException{\n        var L = node.getL();\n        L.apply(this);\n        var R = node.getR();\n        R.apply(this);\n\n        if (L.type.equals(R.type)){\n            //Each operand is of the same type.\n            switch (L.type){\n                case \"int\": case \"float\":{\n                    node.type = L.type;\n                    break;\n                }\n                default:{\n                    // incompatible types\n                    throw new TypeException(node.getOperator(), \"Operation cannot be done on operands of type \" + L.type);\n                }\n            }\n        }\n        else {\n            //Operands are of different types\n            if (L.type.equals(\"int\") && R.type.equals(\"float\") || L.type.equals(\"float\") && R.type.equals(\"int\")){\n                node.type = \"float\";\n            } else {\n                throw new TypeException(node.getOperator(), \"Operation cannot be done on operands of type \" + L.type + \" and \" + R.type);\n            }\n\n        }\n    }\n\n    @Override\n    public void caseAListExpr(AListExpr node) throws TypeException{\n        // Each element is an expression\n        for (PExpr p : node.getElements()){\n            p.apply(this);\n        }\n    }\n\n    @Override\n    public void caseABoolOpExpr(ABoolOpExpr node) throws TypeException {\n        var L = node.getL();\n        L.apply(this);\n        var R = node.getR();\n        R.apply(this);\n\n        if(L.type.equals(\"bool\") && R.type.equals(\"bool\")){\n            node.type = \"bool\";\n        }\n        else {\n            throw new TypeException(node.getOperator(), \"Expression is not of type boolean\");\n        }\n    }\n\n    @Override\n    public void caseARelationExpr(ARelationExpr node) throws TypeException {\n        var L = node.getL();\n        L.apply(this);\n        var R = node.getR();\n        R.apply(this);\n\n        if(L.type.equals(R.type)){\n            switch (L.type){\n                case \"int\": case \"float\": {\n                    node.type = \"bool\";\n                }\n                default:{\n                    //Types that cannot be compared\n                    throw new TypeException(node.getOperator(), \"Cannot compare operands of type \" + L.type);\n                }\n            }\n        }\n        else{\n            if(L.type.equals(\"int\") && R.type.equals(\"float\") || R.type.equals(\"int\") && L.type.equals(\"float\")){\n                node.type = \"bool\";\n            }\n            else {\n                throw new TypeException(node.getOperator(), \"Cannot compare operands of type \" + L.type + \"and \" + R.type);\n            }\n        }\n    }\n\n    @Override\n    public void caseAEqualityExpr(AEqualityExpr node) throws  TypeException {\n        // Check children\n        var L = node.getL();\n        L.apply(this);\n        var R = node.getR();\n        R.apply(this);\n\n        //TODO: Reference types?\n        //Only possible if operands are of same type\n        if (L.type.equals(R.type)){\n            node.type = \"bool\";\n        }\n        else{\n            throw new TypeException(node.getOperator(), \"Cannot compare operands of type \" + L.type + \" and \" + R.type);\n        }\n    }\n\n    @Override\n    public void caseAVal(AVal node) throws TypeException {\n        // Check children\n        for(PCallField cf : node.getCallField()){\n            cf.apply(this);\n        }\n\n        // Node type = type of last element in call sequence\n        node.type = node.getCallField().getLast().type;\n    }\n\n\n    @Override\n    public void caseAFieldCallField(AFieldCallField node) throws TypeException {\n        // Get declaration node\n        var dcl = node.getId().declarationNode;\n        if(dcl instanceof ASingleDcl){\n            // Type of variable is type of declaration node\n            node.type = ((ASingleDcl) dcl).getExpr().type;\n        }\n        else{\n            // if declaration node is not a ASINGLEDCL something went wrong\n            throw new TypeException(node.getId(),\"An unknown type error occurred\");\n        }\n\n    }\n\n    @Override\n    public void caseACallCallField(ACallCallField node) throws TypeException{\n        // Apply on parameters\n        for (PExpr p: node.getParams()){\n            p.apply(this);\n        }\n\n        // Get declaration node\n        var dcl = node.getId().declarationNode;\n        if (dcl instanceof AMethodDcl){\n            node.type = st.retrieveSymbol(((AMethodDcl) dcl).getName().toString()).getType();\n        }\n        else {\n            throw new TypeException(node.getId(), \"An unknown type error has occurred\");\n        }\n    }\n\n    @Override\n    public void caseAMethodDcl(AMethodDcl node) throws TypeException{\n        // Apply on method body\n        for(PStmt s: node.getBody()){\n            s.apply(this);\n        }\n    }\n\n    @Override\n    public void caseAAssignStmt(AAssignStmt node) throws TypeException{\n        var pVal = node.getVar();\n        pVal.apply(this);\n        var pExpr = node.getExpr();\n        pExpr.apply(this);\n\n        if (!pVal.type.equals(pExpr.type)){\n            // If types are incompatible, throw exception.\n            throw new TypeException(node.getOperation(), \"Cannot assign type \" + pVal.type + \" to type \" + pExpr.type);\n        }\n\n        //TODO: Finish AAssignStmt\n    }\n\n\n    @Override\n    public void caseAReturnStmt(AReturnStmt node) throws TypeException{\n        var expr = node.getExpr();\n        expr.apply(this);\n        //TODO: Fix this\n    }\n\n    @Override\n    public void caseAForStmt(AForStmt node) throws TypeException{\n        // Apply to the statement body\n        for (PStmt s : node.getThen()){\n            s.apply(this);\n        }\n\n        // init is an assign statement. Has already been type checked.\n        var initStmt = node.getInit();\n        initStmt.apply(this);\n        // Update is a statement.\n        var update = node.getUpdate();\n        update.apply(this);\n\n        // Predicate is an expression.\n        var predicate = node.getPredicate();\n        predicate.apply(this);\n        if (!predicate.type.equals(\"bool\")){\n            node.apply(tf);\n            throw new TypeException(tf.getToken(), \"Predicate does not return type boolean\");\n        }\n    }\n\n    @Override\n    public void caseAWhileStmt(AWhileStmt node) throws TypeException{\n        // Apply on statement body\n        for (PStmt s : node.getThen()){\n            s.apply(this);\n        }\n        // Predicate is an expression.\n        var predicate = node.getPredicate();\n        predicate.apply(this);\n        if (!(predicate.type.equals(\"bool\"))){\n            node.apply(tf);\n            throw new TypeException(tf.getToken(), \"Predicate does not return type boolean\");\n        }\n    }\n\n    @Override\n    public void caseASwitchStmt(ASwitchStmt node) throws TypeException{\n        // Apply on each case\n        for (PCase pc : node.getCases()){\n            pc.apply(this);\n        }\n\n        //TODO: Do we care about the type of the value?\n    }\n\n    @Override\n    public void caseACaseCase(ACaseCase node) throws TypeException{\n        // Apply on body of each case\n        for (PStmt s : node.getThen()){\n            s.apply(this);\n        }\n\n        // Each case is an expression\n        var pExpr = node.getCase();\n        pExpr.apply(this);\n        //TODO: Make correct.\n    }\n\n    @Override\n    public void caseADefaultCase(ADefaultCase node) throws TypeException{\n        // Apply to body of the default statement\n        for (PStmt ps : node.getThen()){\n            ps.apply(this);\n        }\n    }\n\n    @Override\n    public void caseAForeachStmt(AForeachStmt node) throws TypeException{\n        // Apply on statement body\n        for (PStmt ps : node.getThen()){\n            ps.apply(this);\n        }\n\n        // Foreach stmt only works on collections\n        var pVal = node.getList();\n        pVal.apply(this);\n        if (!pVal.type.equals(\"list\")){\n            throw new TypeException(node.getId(), pVal.type + \" is not a collection\");\n        }\n    }\n\n    @Override\n    public void caseAIfStmt(AIfStmt node) throws TypeException{\n        var expr = node.getPredicate();\n        expr.apply(this);\n        for (PStmt ps : node.getThen()){\n            ps.apply(this);\n        }\n        for (PElseIf ps : node.getElseifs()){\n            ps.apply(this);\n        }\n        for (PStmt ps : node.getElse()){\n            ps.apply(this);\n        }\n\n        node.apply(tf);\n        if(!expr.type.equals(\"bool\")){\n            throw new TypeException(tf.getToken(), \"Predicate is not of type boolean\");\n        }\n    }\n\n    @Override\n    public void caseAElseIf(AElseIf node) throws TypeException{\n        // Apply on statement body\n        for (PStmt ps : node.getThen()){\n            ps.apply(this);\n        }\n        // Check predicate for type correctness\n        var predicate = node.getPredicate();\n        predicate.apply(this);\n        if (!predicate.type.equals(\"bool\")){\n            node.apply(tf);\n            throw new TypeException(tf.getToken(), \"Predicate is not of type boolean\");\n        }\n    }\n\n    @Override\n    public void caseADclStmt(ADclStmt node) throws TypeException{\n        for (PSingleDcl dcl : node.getDcls()){\n            dcl.apply(this);\n        }\n    }\n\n    @Override\n    public void caseASubclass(ASubclass node) throws TypeException{\n        var body = node.getBody();\n        body.apply(this);\n    }\n\n    @Override\n    public void caseASetup(ASetup node) throws TypeException{\n        var card = node.getCard();\n        card.apply(this);\n        var player = node.getPlayer();\n        player.apply(this);\n\n        for(PStmt p : node.getGame()){\n            p.apply(this);\n        }\n\n    }\n\n\n    @Override\n    public void caseASingleDcl(ASingleDcl node) throws TypeException{\n        var expr = node.getExpr();\n        expr.apply(this);\n\n        var type = st.retrieveSymbol(node.getId().toString()).getType();\n\n        if(!expr.type.equals(type)){\n            throw new TypeException(node.getId(), \"Type does not match the expression\");\n        }\n\n    }\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/P4/contextualAnalysis/TypeChecker.java	(revision 3de796a0f04b1b646cff0ff368b6d49a11ab04d5)
+++ src/P4/contextualAnalysis/TypeChecker.java	(date 1588844238795)
@@ -59,7 +59,9 @@
         }
 
         var pConstruct = node.getConstruct();
-        pConstruct.apply(this);
+        if(pConstruct != null) {
+            pConstruct.apply(this);
+        }
     }
 
     @Override
