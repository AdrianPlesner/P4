Index: src/P4/contextualAnalysis/STBuilder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package P4.contextualAnalysis;\n\nimport P4.Sable.analysis.DepthFirstAdapter;\nimport P4.Sable.lexer.Lexer;\nimport P4.Sable.node.*;\nimport P4.Sable.parser.Parser;\nimport P4.contextualAnalysis.Symbol.*;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.PushbackReader;\nimport java.util.LinkedList;\n\npublic class STBuilder extends DepthFirstAdapter {\n\n    private Start ast;\n\n    private SymbolTable st;\n\n    private Symbol current;\n\n    private String path;\n\n    private LinkedList<TypeError> errors = new LinkedList<>();\n\n    public STBuilder(Start ast, String contentPath) {\n        this.ast = ast;\n        this.path = contentPath;\n    }\n\n    // Construct the given symbol table from the ast\n    public SymbolTable BuildST(SymbolTable st) throws TypeException {\n        this.st = st;\n        // Add standard environment\n        createStdEnv();\n        ast.apply(this);\n\n        return this.st;\n    }\n\n    public String getErrorList(){\n        String result = \"\";\n        return result;\n    }\n\n    public boolean hasTypeErrors(){\n        return errors.size() > 0;\n    }\n\n    private void addToCurrent(Variable v) throws TypeException {\n        if(current == null){\n            st.enterSymbol(v);\n        }\n        else if(current instanceof SubClass){\n            ((SubClass) current).addLocal(v);\n        }\n        else if(current instanceof Function){\n            ((Function) current).addArg(v);\n        }\n        else{\n            throw new TypeException(null,\"An unknown type error occurred\");\n        }\n    }\n    private void addToCurrent(Function f) throws TypeException {\n        if(current == null){\n            st.enterSymbol(f);\n        }\n        else if(current instanceof SubClass){\n            ((SubClass) current).addMethod(f);\n        }\n        else{\n            throw new TypeException(null,\"An unknown type error occurred\");\n        }\n    }\n\n    private void createStdEnv(){\n        st.enterSymbol(new SubClass(\"int\",null,null));\n        st.enterSymbol(new SubClass(\"float\",null,null));\n        st.enterSymbol(new SubClass(\"string\",null,null));\n        st.enterSymbol(new SubClass(\"bool\",null,null));\n        st.enterSymbol(new SubClass(\"void\",null,null));\n        st.enterSymbol(new SubClass(\"card\",null,null));\n        st.enterSymbol(new SubClass(\"player\",null,null));\n        var list = new GenericClass(\"list\",null,null);\n        st.enterSymbol(list);\n        list.addLocal(new Variable(\"length\",null,\"int\"));\n        var take = new Function(\"take\",null,null);\n        take.addArg(new Variable(\"num\",null,\"int\"));\n        list.addMethod(take);\n        var find = new Function(\"find\",null,null);\n        list.addMethod(find);\n        find.addArg(new Variable(\"n\",null,\"string\"));\n        st.enterSymbol(new Function(\"GetStdDeck\",null,\"list of card\"));\n        var Turn = new SubClass(\"Turn\",null,null);\n        st.enterSymbol(Turn);\n        Turn.addLocal(new Variable(\"current\",null,\"player\"));\n        st.enterSymbol(new Variable(\"turn\",null,\"Turn\"));\n        var chooseFrom = new Function(\"chooseFrom\",null,null);\n        chooseFrom.addArg(new GenerecVariable(\"l\",null,\"list\",null));\n    }\n\n    @Override\n    public void caseAProg(AProg node) throws TypeException {\n\n        var includes = node.getIncludes();\n        for(TId inc : includes){\n            // Something about reading a file and adding everything to symboltable\n            //TODO: include includes\n            try {\n                Lexer lexer = new Lexer(new PushbackReader(new BufferedReader(new FileReader(path.concat(inc.getText()).concat(\".cl\"))), 1024));\n\n                // parser program\n                Parser parser = new Parser(lexer);\n                // Debug med System.out.println(this.token.getClass().getSimpleName() + \": [\" + token.getText() + \"]\");\n                Start ast = parser.parse();\n                node.includes.add(ast);\n\n            }\n            catch(Exception e){\n                System.out.println(e);\n            }\n        }\n        for(Start ast : node.includes){\n            ast.apply(this);\n        }\n\n        // Do Setup\n        if(node.getSetup() != null){\n            node.getSetup().apply(this);\n        }\n\n        // Do method declarations\n        var methods = node.getMethods();\n        for(PMethodDcl m : methods){\n            m.apply(this);\n        }\n\n        // Do Moves\n        var moves = node.getMoves();\n        for(PMethodDcl move : moves)\n        {\n            move.apply(this);\n        }\n\n        // Do Turn\n        var turn = node.getTurn();\n        for(PStmt stmt : turn){\n            stmt.apply(this);\n        }\n\n        // Do EndCondition\n        var endcon = node.getEndCondition();\n        for(PStmt stmt : endcon){\n            stmt.apply(this);\n        }\n\n        // Check method bodies\n        for(PMethodDcl m : methods){\n            m.apply(this);\n        }\n        // check move bodies\n        for(PMethodDcl move : moves)\n        {\n            move.apply(this);\n        }\n\n    }\n\n    @Override\n    public void caseASetup(ASetup node) throws TypeException {\n        // Add card\n        SubClass card;\n        card = (SubClass) st.retrieveSymbol(\"card\");\n        if(card == null) {\n            card = new SubClass(\"card\", node.getCard(), null);\n            st.enterSymbol(card);\n        }\n        current = card;\n        node.getCard().apply(this);\n        current = null;\n\n        // Add player\n        SubClass player;\n        player = (SubClass) st.retrieveSymbol(\"player\");\n        if(player == null) {\n            player = new SubClass(\"player\", node.getPlayer(), null);\n            st.enterSymbol(player);\n        }\n        current = player;\n        node.getPlayer().apply(this);\n        current = null;\n\n        // Do game\n        for(PStmt ps : node.getGame()){\n            ps.apply(this);\n        }\n\n\n    }\n\n    @Override\n    public void caseAMethodDcl(AMethodDcl node) throws TypeException {\n        // check name\n        var name = node.getName().getText();\n        if(st.declaredLocally(name)){\n            var fun = st.retrieveSymbol(name);\n            if(fun.getDeclarationNode().equals(node)){\n                st.openScope();\n                for(var p : ((Function)fun).getArgs()){\n                    if(st.declaredLocally(p.getIdentifier())){\n                        throw new IdentifierAlreadyExistsException(null,\"Parameter \" + p.getIdentifier() + \" in function \" + fun.getIdentifier());\n                    }\n                    st.enterSymbol(p);\n                }\n                // Check body\n                var prev = current;\n                current = null;\n                for (PStmt stmt : node.getBody()) {\n                    stmt.apply(this);\n                }\n                current = prev;\n                st.closeScope();\n            }\n            throw new IdentifierAlreadyExistsException(node.getName(), fun + \" already exsists\");\n        }\n        else {\n            // Declare function\n            var returnType = node.getReturntype();\n            //Check returntype\n            returnType.apply(this);\n            var method = new Function(name, node, returnType.toString());\n\n            var prev = current;\n            current = method;\n            // Check arguments\n            for (PParamDcl pd : node.getParams()) {\n                pd.apply(this);\n            }\n\n            current = prev;\n            addToCurrent(method);\n        }\n\n    }\n\n    @Override\n    public void caseAParamDcl(AParamDcl node) throws TypeException {\n        // Check type is valid\n        node.getType().apply(this);\n\n        // Check name is valid\n        var name = node.getName().getText();\n        if(((Function)current).containsArg(name)){\n            throw new IdentifierAlreadyExistsException(node.getName(),\"A parameter with \" + name\n                    + \" already exists in method \"+ ((AMethodDcl)node.parent()).getName().getText());\n        }\n        addToCurrent(new Variable(name, node, node.getType().toString()));\n    }\n\n    @Override\n    public void caseAClassBody(AClassBody node) throws TypeException {\n        if(current != null){\n\n            // Add locals\n            for(PStmt dcl : node.getDcls()){\n                // Check if statement is a declare\n                if(dcl instanceof ADclStmt){\n                    // Each var in declare statement\n                    dcl.apply(this);\n                }\n                else{\n                    // Statement is not a declare\n                    throw new TypeException(null,\"A subclass can only have declare statements.\");\n                }\n            }\n\n            // Add method declarations\n            for(PMethodDcl md : node.getMethods()){\n                md.apply(this);\n            }\n            // Do method bodies\n            for(PMethodDcl md : node.getMethods()){\n                md.apply(this);\n            }\n\n            // Add subclasses\n            for(PSubclass sc : node.getSubclasses()){\n                sc.apply(this);\n            }\n        }\n        else {\n            //report error\n            throw new TypeException(null, \"An unknown type error occurred.\");\n        }\n    }\n\n    @Override\n    public void caseASubclass(ASubclass node) throws TypeException {\n        // check name\n        var name = node.getName().getText();\n        if(st.containsClass(name)){\n            // Name already exists\n            throw new TypeException(node.getName(),\"A (sub)class named \" + name + \" already exists.\");\n        }\n        // Do class body\n        var sub = new SubClass(name,node, (SubClass) current);\n        st.enterSymbol(sub);\n        current = sub;\n        node.getBody().apply(this);\n        current = sub.getSuperClass();\n        // Add subclass to superclass\n        ((SubClass)current).addSubclass(sub);\n\n    }\n\n    @Override\n    public void caseADclStmt(ADclStmt node) throws TypeException {\n        // Validate type\n        var typeNode = node.getType();\n        typeNode.apply(this);\n        var type = node.getType().toString().trim();\n        for(PSingleDcl sDcl : node.getDcls()){\n            // Validate singleDcl\n            sDcl.apply(this);\n\n            // expression type and declare type are the same\n            Variable v;\n            if(typeNode instanceof AVarType) {\n                v = new Variable(((ASingleDcl) sDcl).getId().getText(), sDcl, type);\n            }\n            else if(typeNode instanceof AListType){\n                v = new GenerecVariable(((ASingleDcl) sDcl).getId().getText(), sDcl,\"list\",type);\n            }\n            else{\n                throw new TypeException(null,\"An unknown type error occurred\");\n            }\n            addToCurrent(v);\n        }\n    }\n\n    //TODO: check for subclass\n    @Override\n    public void caseAVarType(AVarType node) throws TypeException {\n        var s = st.retrieveSymbol(node.getType().getText());\n        if(! (s instanceof SubClass)){\n            //Type is not a valid type\n            throw new InvalidTypeException(node.getType(),\"\");\n        }\n    }\n\n    @Override\n    public void caseAListType(AListType node) throws TypeException {\n        var s = st.retrieveSymbol(node.getType().getText());\n        if(! (s instanceof SubClass)){\n            //Type is not a valid type\n            throw new InvalidTypeException(node.getType(),\"\");\n        }\n    }\n\n    @Override\n    public void caseASingleDcl(ASingleDcl node) throws TypeException {\n        // Check if ID exists locally\n        if( st.declaredLocally(node.getId().getText())){\n            throw new TypeException(node.getId(),\"Identifier already exists locally\");\n        }\n        // Check that expression is OK\n        if(node.getExpr() != null) {\n            node.getExpr().apply(this);\n        }\n    }\n\n    @Override\n    public void caseAAssignStmt(AAssignStmt node) throws TypeException {\n        node.getVar().apply(this);\n        node.getExpr().apply(this);\n    }\n\n    @Override\n    public void caseAVal(AVal node) throws TypeException {\n        var prev = current;\n        for(PCallField cf : node.getCallField()){\n            //Check call/field is valid\n            cf.apply(this);\n\n        }\n        if (current != null) {\n            node.type = current.getType();\n        }\n        else{\n            throw new TypeException(null,\"An unknown type error occurred\");\n        }\n        current = prev;\n    }\n\n    @Override\n    public void caseACallCallField(ACallCallField node) throws TypeException {\n        var name = node.getId().getText();\n        Symbol dcl;\n        if(current == null){\n            // Base call, lookup at symbol table\n            dcl = st.retrieveSymbol(name);\n        }\n        else{\n            // Call on a variable\n            if(current instanceof SubClass){\n                dcl = ((SubClass) current).containsMethod(name);\n            }\n            else{\n                throw new TypeException(null,\"An unknown type error occurred\");\n            }\n        }\n        // Set delcaration node\n        if(dcl instanceof Function){\n            var type = ((Function) dcl).getReturnType();\n\n            if(type == null){\n                // unknown classvariable\n                type = ((GenericClass)st.retrieveSymbol(\"list\")).getClassVariable();\n            }\n            else if(type.startsWith(\"list of\")){\n                // known class variable\n                ((GenericClass)st.retrieveSymbol(\"list\")).setClassVariable(type.substring(8));\n                type = \"list\";\n            }\n\n            current = st.retrieveSymbol(type);\n            if(current == null){\n                // Return type dont exist\n                throw new InvalidTypeException(node.getId(),((Function) dcl).getReturnType());\n            }\n        }\n        else{\n            throw new TypeException(node.getId(),\"Method \" + node.getId().getText() + \" does not exists in the current context\");\n        }\n\n\n        node.getId().declarationNode = dcl.getDeclarationNode();\n    }\n\n    @Override\n    public void caseAFieldCallField(AFieldCallField node) throws TypeException {\n        var name = node.getId().getText();\n        Symbol dcl = null;\n        if(current == null){\n            // Base call, lookup at symboltable\n            dcl = st.retrieveSymbol(name);\n        }\n        else{\n            // Field on variable\n            if(current instanceof SubClass){\n                dcl = ((SubClass)current).containsVariable(name);\n            }\n            else{\n                throw new TypeException(node.getId(),\"Unknown type error occured\");\n            }\n        }\n        if(! (dcl instanceof Variable)){\n            throw new TypeException(node.getId(),\"Variable \" + name + \" does not exists in the current context\");\n        }\n        current = st.retrieveSymbol(dcl.getType());\n        // Handle list\n        if(current instanceof GenericClass && dcl instanceof GenerecVariable){\n            ((GenericClass) current).setClassVariable(((GenerecVariable) dcl).getClassVariable());\n        }\n\n        node.getId().declarationNode = dcl.getDeclarationNode();\n    }\n\n    @Override\n    public void caseAReturnStmt(AReturnStmt node) throws TypeException {\n        node.getExpr().apply(this);\n    }\n\n    @Override\n    public void caseACallStmt(ACallStmt node) throws TypeException {\n        node.getVal().apply(this);\n    }\n\n    @Override\n    public void caseAIfStmt(AIfStmt node) throws TypeException {\n        node.getPredicate().apply(this);\n\n        st.openScope();\n        for(PStmt s :node.getThen()){\n            s.apply(this);\n        }\n        st.closeScope();\n\n        for(PElseIf ei : node.getElseifs()){\n            ei.apply(this);\n        }\n        st.openScope();\n        for(PStmt s : node.getElse()){\n            s.apply(this);\n        }\n        st.closeScope();\n    }\n\n    @Override\n    public void caseAForeachStmt(AForeachStmt node) throws TypeException {\n\n        node.getList().apply(this);\n        var type = node.getList().type;\n        if(!type.startsWith(\"List of\")){\n            throw new TypeException(node.getId(),\"Iteration variable must be a list\");\n        }\n        type = type.substring(7);\n\n        st.openScope();\n        st.enterSymbol(new Variable(node.getId().getText(),node,type));\n        for(PStmt s : node.getThen()){\n            s.apply(this);\n        }\n        st.closeScope();\n    }\n\n    @Override\n    public void caseAForStmt(AForStmt node) throws TypeException {\n        st.openScope();\n\n        node.getInit().apply(this);\n\n        node.getPredicate().apply(this);\n\n        node.getUpdate().apply(this);\n\n        for(PStmt s : node.getThen()){\n            s.apply(this);\n        }\n\n        st.closeScope();\n    }\n\n    @Override\n    public void caseASwitchStmt(ASwitchStmt node) throws TypeException {\n        node.getVariable().apply(this);\n        for(PCase c : node.getCases()){\n            c.apply(this);\n        }\n    }\n\n    @Override\n    public void caseACaseCase(ACaseCase node) throws TypeException {\n        node.getCase().apply(this);\n        st.openScope();\n        for(PStmt s : node.getThen()){\n            s.apply(this);\n        }\n        st.closeScope();\n    }\n\n    @Override\n    public void caseADefaultCase(ADefaultCase node) throws TypeException {\n        st.openScope();\n        for(PStmt s : node.getThen()){\n            s.apply(this);\n        }\n        st.closeScope();\n    }\n\n    @Override\n    public void caseAWhileStmt(AWhileStmt node) throws TypeException {\n        node.getPredicate().apply(this);\n        st.openScope();\n        for(PStmt s : node.getThen()){\n            s.apply(this);\n        }\n        st.closeScope();\n    }\n\n    @Override\n    public void caseAElseIf(AElseIf node) throws TypeException {\n        node.getPredicate().apply(this);\n        st.openScope();\n        for(PStmt s : node.getThen()){\n            s.apply(this);\n        }\n        st.closeScope();\n    }\n\n    @Override\n    public void caseAEqualityExpr(AEqualityExpr node) throws TypeException {\n        node.getL().apply(this);\n        node.getR().apply(this);\n    }\n\n    @Override\n    public void caseARelationExpr(ARelationExpr node) throws TypeException {\n        node.getL().apply(this);\n        node.getR().apply(this);\n    }\n\n    @Override\n    public void caseAAddOpExpr(AAddOpExpr node) throws TypeException {\n        node.getL().apply(this);\n        node.getR().apply(this);\n    }\n\n    @Override\n    public void caseABoolOpExpr(ABoolOpExpr node) throws TypeException {\n        node.getL().apply(this);\n        node.getR().apply(this);\n    }\n\n    @Override\n    public void caseAMultOpExpr(AMultOpExpr node) throws TypeException {\n        node.getL().apply(this);\n        node.getR().apply(this);\n    }\n\n    @Override\n    public void caseAListExpr(AListExpr node) throws TypeException {\n        for(PElement e : node.getElements()){\n            e.apply(this);\n        }\n    }\n\n    @Override\n    public void caseAElement(AElement node) throws TypeException {\n        for(PExpr e : node.getValues()){\n            e.apply(this);\n        }\n    }\n\n    @Override\n    public void caseAValueExpr(AValueExpr node) throws TypeException {\n        node.getVal().apply(this);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/P4/contextualAnalysis/STBuilder.java	(revision f496b376ec8d749f42e02f5d87dfad070e9e7781)
+++ src/P4/contextualAnalysis/STBuilder.java	(date 1587978623186)
@@ -90,13 +90,10 @@
         var find = new Function("find",null,null);
         list.addMethod(find);
         find.addArg(new Variable("n",null,"string"));
-        st.enterSymbol(new Function("GetStdDeck",null,"list of card"));
         var Turn = new SubClass("Turn",null,null);
         st.enterSymbol(Turn);
         Turn.addLocal(new Variable("current",null,"player"));
         st.enterSymbol(new Variable("turn",null,"Turn"));
-        var chooseFrom = new Function("chooseFrom",null,null);
-        chooseFrom.addArg(new GenerecVariable("l",null,"list",null));
     }
 
     @Override
@@ -221,14 +218,27 @@
                 current = prev;
                 st.closeScope();
             }
-            throw new IdentifierAlreadyExistsException(node.getName(), fun + " already exsists");
+            else {
+                throw new IdentifierAlreadyExistsException(node.getName(), fun + " already exsists");
+            }
         }
         else {
             // Declare function
             var returnType = node.getReturntype();
             //Check returntype
             returnType.apply(this);
-            var method = new Function(name, node, returnType.toString());
+            var type = returnType.toString();
+            if(returnType instanceof AListType){
+                if(type.equals("void")){
+                    // List of unknow type
+                    type = "list";
+                }
+                else{
+                    // List of static type
+                    type = "list of " + type;
+                }
+            }
+            var method = new Function(name, node, type);
 
             var prev = current;
             current = method;
@@ -355,6 +365,7 @@
             //Type is not a valid type
             throw new InvalidTypeException(node.getType(),"");
         }
+
     }
 
     @Override
