Package P4.Sable;

Helpers
    digit = ['0' .. '9'];
    letter = ['a' .. 'z'] | ['A' .. 'Z'];
    cr = 13;
    lf = 10;
    tab = 9;
    eol = cr lf | cr | lf;
    blank_help = (' ' | tab | eol)+;
    all = [0 .. 0xFFFF];
    not_cr_lf = [all - [cr + lf]];

Tokens
    blank = blank_help;
    comment = '//' not_cr_lf* eol;
    bool_literal = 'true'|'false';
    add_op = '+' | '-';
    mult_op = '*' | '/' | '%';
    int_literal = digit*;
    float_literal = ['1' .. '9'] digit*'.'digit*;
    string = '"' [not_cr_lf - '"']* '"';
    bool_op = '|' | '&';
    relation_op = '<' | '>' | '<=' | '>=';
    assign = '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=';
    equal_op = '==' | '!=';
    l_paren = '(';
    r_paren = ')';
    l_brack = '{';
    r_brack = '}';
    setup = 'Setup';
    public = 'Public';
    private = 'Private';
    separator = ',';
    dot = '.';
    moves = 'Moves';
    l_box = '[';
    r_box = ']';
    return = 'return';
    semi = ';';
    if = 'if';
    else = 'else';
    switch = 'switch';
    case = 'case';
    default = 'default';
    colon = ':';
    while = 'while';
    for = 'for';
    foreach = 'foreach';
    turn = 'Turn';
    end_con = 'EndCondition';
    in = 'in';
    card = 'Card';
    l_arr = '<';
    r_arr = '>';
    list = 'List';
    typeof = 'typeof';
    fun = 'Function';
    inc = 'include';
    sub = 'Subclass';
    id = letter (letter |digit)*;

Ignored Tokens
    blank, comment;

Productions
    prog = include* P.setup P.moves P.turn P.end_con method_dcl* {-> New prog([include.id], setup, moves, turn, end_con, [method_dcl])};
    include{-> id} = inc id semi {-> id };
    setup = T.setup l_brack P.card P.public P.private stmt* r_brack {-> New setup(card, public, private, [stmt])};
    card = T.card class_body {-> New card([class_body.stmt], [class_body.method_dcl], [class_body.subclass])};
    class_body = l_brack stmt* method_dcl* subclass* r_brack;
    subclass = sub id class_body;
    public = T.public block;
    private = T.private class_body;
    moves = T.moves l_brack method_dcl* r_brack;
    dcl = type single_dcl dcl_list*;
    single_dcl = id init?;
    dcl_list = separator single_dcl;
    init = assign expr;
    expr = {expand} expr bool_op equality | {single} equality;
    equality = {expand} equality equal_op relation  | {single} relation;
    relation = {expand} relation relation_op add_expr | {single} add_expr;
    add_expr = {expand} add_expr add_op term | {single} term;
    term = {expand} term mult_op factor | {factor} factor;
    factor = {expand} parens | {literal} literal | {val} val | {init} l_brack element_list* r_brack;
    parens = l_paren expr r_paren;
    literal = {int} int_literal | {float} float_literal | {string} string | {bool} bool_literal;
    element_list = element semi;
    element = {expand} expr separator element | {single} expr;
    val = id call? val_list*;
    val_list = dot id call?;
    call = l_paren param_list? r_paren;
    param_list = expr param*;
    param = separator expr;
    method_dcl = fun id l_paren param_dcl_list? r_paren typeof type l_brack stmt* return_stmt? r_brack;
    param_dcl_list = param_dcl expand_param*;
    expand_param = separator param_dcl;
    param_dcl = type id;
    type = P.list? id;
    list = T.list typeof;
    return_stmt = return expr semi;
    stmt = {select} select_stmt | {dcl} dcl end | {loop} loop_stmt | {assign} assign_value end | {call} val end;
    select_stmt = {if} if_stmt | {switch} switch_stmt;
    block = l_brack stmt* r_brack;
    if_stmt = if expr block else_if* else_stmt?;
    else_if = else if expr block;
    else_stmt = else block;
    switch_stmt = switch val l_brack P.case+ r_brack;
    case = case_stmt colon block;
    case_stmt = {case} T.case | {default} default;
    loop_stmt = {while} while_loop | {for} for_loop;
    while_loop = while expr block;
    for_loop = for loop_expr block;
    loop_expr = {foreach} id in val | {for} init_loop [a]:semi expr [b]:semi assign_value;
    init_loop = {declare} dcl | {assign} assign_value;
    assign_value = val assign expr;
    turn = T.turn block;
    end_con = T.end_con block;
    end = semi;

Abstract Syntax Tree
    prog = [includes]:id* P.setup P.moves P.turn P.end_con [methods]:method_dcl*;
