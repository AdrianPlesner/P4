Package P4.Sable;

Helpers
    digit = ['0' .. '9'];
    letter = ['a' .. 'z'] | ['A' .. 'Z'];
    cr = 13;
    lf = 10;
    tab = 9;
    eol = cr lf | cr | lf;
    blank_help = (' ' | tab | eol)+;
    all = [0 .. 0xFFFF];
    not_cr_lf = [all - [cr + lf]];

Tokens
    blank = blank_help;
    comment = '//' not_cr_lf* eol;
    bool_literal = 'true'|'false';
    add_op = '+' | '-';
    mult_op = '*' | '/' | '%';
    int_literal = digit*;
    float_literal = ['1' .. '9'] digit*'.'digit*;
    string = '"' [not_cr_lf - '"']* '"';
    bool_op = '||' | '&&';
    relation_op = '<' | '>' | '<=' | '>=';
    assign = '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=';
    equal_op = '==' | '!=';
    l_paren = '(';
    r_paren = ')';
    l_brack = '{';
    r_brack = '}';
    setup = 'Setup';
    public = 'Public';
    private = 'Private';
    separator = ',';
    dot = '.';
    moves = 'Moves';
    l_box = '[';
    r_box = ']';
    return = 'return';
    semi = ';';
    if = 'if';
    else = 'else';
    switch = 'switch';
    case = 'case';
    default = 'default';
    colon = ':';
    while = 'while';
    for = 'for';
    foreach = 'foreach';
    turn = 'Turn';
    end_con = 'EndCondition';
    in = 'in';
    type = 'int' | 'float' | 'string' | 'bool' | 'Card' | 'Player' | 'void';
    l_arr = '<';
    r_arr = '>';
    list = 'List';
    typeof = 'typeof';
    fun = 'Function';
    id = letter (letter |digit)*;

Ignored Tokens
    blank, comment;

Productions
    prog = P.setup P.moves P.turn P.end_con move_dcl_list;
    setup = T.setup l_brack stmt_list P.public P.private r_brack;
    public = T.public block;
    private = T.private block;
    moves = T.moves move_dcl_list;
    dcl_list = {expand} id init separator | {empty} ;
    dcl = P.type dcl_list semi ;
    init = {init} assign expr | {empty};
    expr = {expand} expr bool_op equality | {single} equality;
    equality = {expand} equality equal_op  relation  | {single} relation;
    relation = {expand} relation relation_op add_expr | {single} add_expr;
    add_expr = {expand} add_expr add_op term | {single} term;
    term = {expand} term mult_op factor | {factor} factor;
    factor = {expand} parens | {literal} literal | {val} val | {init} init_list;
    parens = l_paren expr r_paren;
    literal = {int} int_literal | {float} float_literal | {string} string | {bool} bool_literal;
    init_list = l_brack element_list r_brack;
    element_list = {expand} param_list separator element_list | {empty} ;
    val = id call val_list;
    val_list = {expand} dot val | {empty};
    call = {call} id param_list | {empty} ;
    param_list = l_paren expr? param* r_paren;
    param = separator expr;
    move_dcl_list = method_dcl move_dcl_list;
    method_dcl = fun id l_paren param_dcl_list r_paren typeof P.type l_brack stmt_list return_stmt r_brack;
    param_dcl_list = {expand} param_dcl separator param_dcl_list | {single} param_dcl;
    param_dcl = {single} P.type id | {empty};
    type = {type} T.type | {collection} collection;
    collection = {array} array | {list} P.list;
    array = T.type l_box r_box;
    list = T.list typeof T.type ;
    stmt_list = {expand} stmt stmt_list | {empty};
    return_stmt = {single} return expr semi | {empty};
    stmt = {select} select_stmt | {dcl} dcl | {loop} loop_stmt | {call} val semi;
    select_stmt = {if} if_stmt | {switch} switch_stmt;
    block = l_brack stmt_list r_brack;
    if_stmt = if expr block else_stmt;
    else_stmt = {elseif} else if_stmt | {else} else block |;
    switch_stmt = switch l_paren val l_brack case_list r_brack;
    case_list = {list} case_stmt case_list | {default} default_stmt |{empty};
    case_stmt = case colon block;
    default_stmt = default colon block;
    loop_stmt = {while} while_loop | {for} for_loop;
    while_loop = while expr  block;
    for_loop = for loop_expr block;
    loop_expr = {foreach} P.type [var]:id in [collection]:id | {for} [init]:expr [a]:semi [condition]:expr [b]:semi [count]:expr;
    turn = T.turn block;
    end_con = T.end_con block;
